# 5.3 Цикл for. Обход списков и строк
""""""

#  *  *  *   Задачи   *  *  *


# 01
"""
Перед вами список numbers, состоящий из 100 целых чисел
Пройтись в цикле по элементам списка и вывести на экран каждый элемент на отдельной строке
"""
numbers = [99, 50, -16, 9, 47, -62, 5, -64, -68, 85, 11, -20, 16, 96, -43, 46, -25, 33, 81, -30, 64, 66, -11, 60, 3, -5,
           -80, 49, -1, -12, -86, -40, -98, -92, -91, -71, 56, -76, -30, -82, 17, -2, -64, 47, 22, -28, 40, 55, 54, -3,
           -58, -10, -35, -15, -2, -60, 70, 50, -77, 83, -49, 42, 27, -58, -79, -2, -100, -42, -18, 38, 95, 9, 98, -89,
           -46, 96, 64, -35, 41, 94, 1, -90, 29, 23, 39, -3, 11, -65, -64, 52, -69, 32, -14, -49, -28, -11, 85, -75, -6,
           15]

for el in numbers:
    print(el)


# 02
"""
Перед вами список words, состоящий из 100 строк
Ваша задачи пройтись в цикле по элементам списка и вывести на экран только те элементы, длина которых больше 6.
Выводить каждый элемент нужно на отдельной строке в том же порядке, в котором слова расположены в списке words
"""
words = ['require', 'build', 'head', 'land', 'dark', 'seat', 'have', 'five', 'particularly', 'focus', 'moment',
         'visit', 'past', 'turn', 'bad', 'modern', 'once', 'future', 'pay', 'assume', 'himself', 'physical', 'chance',
         'remember', 'better', 'former', 'believe', 'explain', 'reduce', 'whatever', 'theory', 'during', 'enough',
         'wall', 'commercial', 'challenge', 'tell', 'actually', 'include', 'somebody', 'decade', 'by', 'better',
         'would', 'five', 'cost', 'kitchen', 'our', 'affect', 'board', 'practice', 'full', 'instead', 'apply', 'good',
         'past', 'clearly', 'special', 'both', 'analysis', 'peace', 'truth', 'cultural', 'light', 'answer', 'build',
         'each', 'watch', 'buy', 'theory', 'pretty', 'expect', 'account', 'music', 'sell', 'newspaper', 'reach',
         'fish', 'tax', 'employee', 'start', 'most', 'during', 'citizen', 'develop', 'carry', 'only', 'certainly',
         'rock', 'economy', 'risk', 'later', 'one', 'body', 'star', 'they', 'choice', 'appear', 'return', 'sometimes']

for el in words:
    if len(el) > 6:
        print(el)


# 03
"""
Перед вами список numbers, состоящий из 100 целых чисел
Ваша задача пройтись в цикле по элементам списка и увеличить каждый в 2 раза.
В итоге изначальный список numbers  должен измениться
В качестве ответа распечатайте измененный список numbers
"""
numbers = [-35, 68, -91, 23, -92, -82, -74, 32, 39, -30, -100, -29, 54, 26, 54, -45, 20, 53, -17, 68, -35, 11, 26, -17,
           70, 89, -81, -4, 61, -45, 13, 63, -48, -66, -92, -15, -88, -87, -75, 44, -49, -81, 19, -33, -59, 85, -69,
           -60, 9, -98, 28, 11, 15, -35, -80, 5, -20, -52, -45, 26, 47, -16, 40, -14, -12, 15, 73, -16, 29, -98, 93,
           -77, 1, 85, 77, 73, 100, -71, 99, 39, 2, -38, 49, -31, 15, 43, 94, -39, -89, -46, -71, 39, -56, 41, -93, 4,
           -79, 48, 88, -51]

for el in range(len(numbers)):
    numbers[el] *= 2

print(numbers)


# 04
"""
Создать список из n строк. Программа сперва будет принимать натуральное число n, 
а затем n строк в каждой отдельной строке. В качестве ответа выведите получившийся список.
Input:  4
        Джон
        Пол
        Ринго
        Джордж
Output: ['Джон', 'Пол', 'Ринго', 'Джордж']
"""

n = int(input())
s = [(input()) for el in range(n)]
print(s)


# 05
"""
На первой строке вводится один символ — строчная буква.
На второй строке вводится предложение.
Вывести список слов (словом считается часть предложения, окружённая символами пустого пространства), 
в которых присутствует введённая буква в любом регистре, в том же порядке, в каком они встречаются в предложении.
Input:  a
        Mary had a little lamb.
Output: Mary
        had
        a
        lamb.
"""

s, st_in = input(), list(input().split())
res = [el for el in st_in if s in el.lower()]
for el in res:
    print(el)


# 06
"""
Линейный поиск

Вы должны проверять каждый элемент списка последовательно один за другим, 
пока не найдете интересующий вас элемент или пока не закончится весь список.

Программа получает на вход в одной строке элементы списка - целые числа, 
разделенные пробелом. Количество элементов произвольное
И на следующей строке вводится одно число r - значение поиска

Реализовать линейный алгоритм поиска введенного значения r. 
В случае успеха - выведите порядковый номер(индекс) первого найденного элемента в списке  
при условии, что индексация начинается с единицы. 
Если данный элемент отсутствует - необходимо вывести строку   ErrorValue
Input:  8 11 45 32 543 65
        32
Output: 4
"""

ls = list(map(int, input().split()))
num = int(input())

for el in range(len(ls)):
    if ls[el] == num:
        print(el)
        break
else:
    print('ErrorValue')


# 07
"""
На вход программе поступает список из целых чисел. 
Найти в данном списке наименьшее положительное значение. 
В случае, если положительных значений нет, выведите строку "Empty"
Input:  8 11 -9 0 5 -20
Output: 5
"""
ls = map(int, input().split())
positive_ls = [el for el in ls if el > 0]

if positive_ls:
    print(min(positive_ls))
else:
    print('Empty')


# 08
"""
Напишите программу, которая находит рекордное количество вхождений (не обязательно подряд) символа в строку.
Выводится одно целое число — максимальное количество раз, 
которое встречается какая-либо буква (без учёта регистра) или иной символ во введённой строке.
Input:  Сокол
Output: 2
"""
s = input().lower()
srt_set = set(list(s))
res = [s.count(el) for el in srt_set]
print(max(res))


# 09
"""
На вход программе подается строка, состоящая из различных символов: буквы, цифры, знаки препинания и т.д.
Определить сколько символов в данной строке являются цифрами и также найти сумму всех этих цифр. 
Например, в строке "Комната 1408" содержится 4 цифры и их сумма равна 13.
В качестве ответа необходимо через пробел вывести 2 числа - количество цифр в введенной строке и их сумму
Input:  Droid R2-D2
Output: 2 4
"""
s = input()
cnt, sum_num = 0, 0

for el in s:
    if el.isdecimal():
        cnt += 1
        sum_num += int(el)

print(cnt, sum_num)


# 10
"""
Для делимости числа на 11 необходимо, 
чтобы разность между суммой цифр, стоящих на четных местах, и суммой цифр, 
стоящих на нечетных местах, делилась на 11.
Требуется написать программу, которая проверит делимость заданного числа на 11.
Выведите “YES”, если число делится на 11, или “NO” иначе.
1012  {1: четное, 0: нечетное, 1: четное, 2: нечетное}
Input:  143
Output: YES
"""
num = input()
odd_num, even_num = 0, 0
for idx, el in enumerate(num):
    if idx % 2 == 0:
        even_num += int(el)
    else:
        odd_num += int(el)

print('YES' if (even_num - odd_num) % 11 == 0 else 'NO')


# 11
"""
На вход программе поступает список из целых чисел. 
Вывести True, если элементы в списке отсортированы по неубыванию. 
В противном случае выведите False
Input:  8 11 13
Output: True
"""
data = list(map(int, input().split()))
flag = True

for idx, el in enumerate(data[:-1]):
    if el > data[idx + 1]:
        flag = False
        break

print(flag)

# Вариант
print(('False', 'True')[data == sorted(data)])


# 12
"""
Правильная скобочная последовательность
Есть последовательность скобочных символов, состоящая только из символов "(" и ")"
Определить является ли введенная скобочная последовательность правильной.
Правильная скобочная последовательность (ПСП) называется строка, состоящая только символов "скобок", 
где каждой закрывающей скобке найдётся соответствующая открывающая. При этом учитывайте, что:
* Пустая последовательность является правильной.
* Если A – ПСП, то (A) – правильные скобочные последовательности.
* Если A и B – правильные скобочные последовательности, то AB – ПСП.
Input:  (())  или  ()()
Output: YES

Input:  (()  или  ))((  или ()())
Output: NO

Логика:
Если значение счетчика стало меньше нуля — значит имеются лишние закрывающие скобки, 
если же строка кончилась, а счетчик до сих пор нулю не равен — есть лишние открывающие. 
"""
s = input()
cnt = 0

for el in s:
    if el == '(':
        cnt += 1
    else:
        cnt -= 1
        if cnt < 0:
            break

print('YES' if cnt == 0 else 'NO')


# 13
"""
Правильная скобочная последовательность 2
Есть последовательность скобочных символов, состоящая только из символов "()[]{}"
Определить является ли введенная скобочная последовательность правильной.
Правильная скобочная последовательность (ПСП) называется строка, состоящая только символов "скобок", 
где каждой закрывающей скобке найдётся соответствующая открывающая (причём того же типа).
При этом учитывайте, что:
* Пустая последовательность является правильной.
* Если A – ПСП,  то (A), [A] и {A} – правильные скобочные последовательности.
* Если A и B – правильные скобочные последовательности, то AB – ПСП.
Input:  (())  или  {[]}()
Output: YES

Input:  [(])  или  {{]}  или ()())
Output: NO
"""
# Решение по методу стека LIFO (последний пришел - первый ушел)
s = input()
flag = True
lifo = []

for el in s:
    if el in '([{':
        lifo.append(el)
    else:
        if not lifo:  # Если список пустой
            flag = False
            break
        else:
            bracket = lifo.pop()
            if el == ')' and bracket == '(':
                continue
            if el == ']' and bracket == '[':
                continue
            if el == '}' and bracket == '{':
                continue
            flag = False  # Если парных скобок не оказалось
            break

print('YES' if flag and not lifo else 'NO')

