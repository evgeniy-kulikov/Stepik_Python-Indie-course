# 5.6 Вложенные циклы
""""""

"""
Цикл называется вложенным, если находится внутри другого цикла.
Формат вложенных циклов:

for <переменная> in <объект>:
    for <переменная> in <объект>:
        <действие>
    <действие>
"""
for i in range(3):
    for j in range(5):
        print("*", end=" ")
# * * * * * * * * * * * * * * *

for i in range(3):
    for j in range(5):
        print("*", end=" ")
    print()  # Переход на новую строчку при помощи пустого принта.
# * * * * *
# * * * * *
# * * * * *

# на протяжении выполнения внутреннего цикла, переменная внешнего цикла "i" является неизменной:
for i in range(3):
    for j in range(5):
        print(i, end=" ")
    print()
# 0 0 0 0 0
# 1 1 1 1 1
# 2 2 2 2 2

#  Если будем выводить переменную "j", то получим уже другой результат:
for i in range(3):
    for j in range(5):
        print(j, end=" ")
    print()
# 0 1 2 3 4
# 0 1 2 3 4
# 0 1 2 3 4

# Обратите внимание на первую строчку: она пустая, поскольку переменная i была равна нулю, значит мы обходили в range(0)
for i in range(5):
    for j in range(i):
        print(j, end=" ")
    print()
#
# 0
# 0 1
# 0 1 2
# 0 1 2 3

#  давайте начинать цикл с единицы
for i in range(1, 5):
    for j in range(1, i + 1):
        print(j, end=" ")
    print()
# 1
# 1 2
# 1 2 3
# 1 2 3 4

#  используем обе переменные
for i in range(1, 3):
    for j in range(10, 12):
        print(i, j)
# 1 10
# 1 11
# 2 10
# 2 11

# То же самое будет, если перебирать строки
for i in "ab":
    for j in "cde":
        print(i, j)
# a c
# a d
# a e
# b c
# b d
# b e

"""
Вложенные циклы часто используют для переборов всех возможных значений.
Допустим, длина пароля – 3, состоит из маленьких и больших латинских букв, 
а также могут быть цифры и знаки пунктуации. 
Необходимо перебрать все возможные значения, которые могут являться паролем.

Для решения подобной задачи импортируем из модуля string переменную printable.
Для большего понимания посмотрим, что из себя представляет данная переменная:
"""
from string import printable
print(printable)
#  0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~

for b1 in printable:
    for b2 in printable:
        for b3 in printable:
            print(b1, b2, b3)
# 0 0 0
# 0 0 1
# 0 0 2
# ...
# 0 0 a
# 0 0 b
# 0 0 c
# 0 0 d
# 0 0 x
# ...
# 0 0 y
# 0 0 z
# 0 0 A
# 0 0 B
# 0 0 C
# 0 0 D
# ...
# 0 0 Y
# 0 0 Z
# 0 0 !
# 0 0 "
# 0 0 #
# 0 0 $
# ...
# 0 0 ~
# ...
# ...

#  составим таблицу умножения
for i in range(1, 11):
    for j in range(1, 11):
        print(i, "*", j, "=", i * j, end=" ")
    print()
# 1 * 1 = 1 1 * 2 = 2 1 * 3 = 3 1 * 4 = 4 1 * 5 = 5 1 * 6 = 6 1 * 7 = 7 1 * 8 = 8 1 * 9 = 9 1 * 10 = 10
# 2 * 1 = 2 2 * 2 = 4 2 * 3 = 6 2 * 4 = 8 2 * 5 = 10 2 * 6 = 12 2 * 7 = 14 2 * 8 = 16 2 * 9 = 18 2 * 10 = 20
# 3 * 1 = 3 3 * 2 = 6 3 * 3 = 9 3 * 4 = 12 3 * 5 = 15 3 * 6 = 18 3 * 7 = 21 3 * 8 = 24 3 * 9 = 27 3 * 10 = 30
# . . .
# . . .
# 9 * 1 = 9 9 * 2 = 18 9 * 3 = 27 9 * 4 = 36 9 * 5 = 45 9 * 6 = 54 9 * 7 = 63 9 * 8 = 72 9 * 9 = 81 9 * 10 = 90
# 10 * 1 = 10 10 * 2 = 20 10 * 3 = 30 10 * 4 = 40 10 * 5 = 50 10 * 6 = 60 10 * 7 = 70 10 * 8 = 80 10 * 9 = 90 10 * 10 = 100

# Нам нужен противоположный результат. Для этого немного изменим код:
for j in range (1, 11):
    for i in range(1, 11):
        print(i, "*", j, "=", i * j, end=" ")
    print()
# 1 * 1 = 1 2 * 1 = 2 3 * 1 = 3 4 * 1 = 4 5 * 1 = 5 6 * 1 = 6 7 * 1 = 7 8 * 1 = 8 9 * 1 = 9 10 * 1 = 10
# 1 * 2 = 2 2 * 2 = 4 3 * 2 = 6 4 * 2 = 8 5 * 2 = 10 6 * 2 = 12 7 * 2 = 14 8 * 2 = 16 9 * 2 = 18 10 * 2 = 20
# 1 * 3 = 3 2 * 3 = 6 3 * 3 = 9 4 * 3 = 12 5 * 3 = 15 6 * 3 = 18 7 * 3 = 21 8 * 3 = 24 9 * 3 = 27 10 * 3 = 30
# . . .
# . . .
# 1 * 8 = 8 2 * 8 = 16 3 * 8 = 24 4 * 8 = 32 5 * 8 = 40 6 * 8 = 48 7 * 8 = 56 8 * 8 = 64 9 * 8 = 72 10 * 8 = 80
# 1 * 9 = 9 2 * 9 = 18 3 * 9 = 27 4 * 9 = 36 5 * 9 = 45 6 * 9 = 54 7 * 9 = 63 8 * 9 = 72 9 * 9 = 81 10 * 9 = 90
# 1 * 10 = 10 2 * 10 = 20 3 * 10 = 30 4 * 10 = 40 5 * 10 = 50 6 * 10 = 60 7 * 10 = 70 8 * 10 = 80 9 * 10 = 90 10 * 10 = 100

"""
Сколько шестибуквенных слов, начинающихся и заканчивающихся согласной буквой и содержащих ровно 2 гласные  
можно составить из букв Т, Ы, К, В, А? Каждая из допустимых букв может входить в слово несколько раз.
"""
for b1 in "tukva":
    for b2 in "tukva":
        for b3 in "tukva":
            for b4 in "tukva":
                for b5 in "tukva":
                    for b6 in "tukva":
                        rez = b1 + b2 + b3 + b4 + b5 + b6
                        if rez[0] in "tkv" and rez[-1] in "tkv":
                            if rez.count("a") + rez.count("u") == 2:
                                print(rez)
# tttuut
# tttuuk
# tttuuv
# tttuat
# tttuak
# ...
# vaavkk
# vaavkv
# vaavvt
# vaavvk
# vaavvv

"""
Эта программа выведет все возможные комбинации, подходящие под условия задачи. 
Только осталось вместо вывода всех этих вариантов добавить счетчик и вывести его:
Большим минусом такой программы является время исполнения, 
поскольку нужно произвести сочетание каждой буквы с каждой. Всего таких способов: 15625
"""
count = 0
for b1 in "tukva":
    for b2 in "tukva":
        for b3 in "tukva":
            for b4 in "tukva":
                for b5 in "tukva":
                    for b6 in "tukva":
                        rez = b1 + b2 + b3 + b4 + b5 + b6
                        if rez[0] in "tkv" and rez[-1] in "tkv":
                            if rez.count("a") + rez.count("u") == 2:
                                count += 1
print(count)  # 1944

"""
Разберём ещё один пример, который будет считать сумму цифр числа
"""
x = int(input())
s = 0
while x > 0:
    s += x % 10
    x //= 10
print(s)
# x = 123
# s = 6


# Вывести число и сумму цифр числа в заданном диапазоне.
for i in range(10, 101):
    x = i
    s = 0
    while x > 0:
        s += x % 10
        x //= 10
    print(i, s)
# 10 1
# 11 2
# 12 3
# 13 4
# 14 5
# ...
# 96 15
# 97 16
# 98 17
# 99 18
# 100 1


#  *  *  *   Задачи   *  *  *

"""
Найти сумму всех четырехзначных натуральных чисел, сумма цифр которых равна 20
Примерами таких чисел являются 9065, 8129, 7355 и тд. У каждого из указанных чисел сумма цифр равна 20
"""
res = 0
for i in range(1000, 10000):
    num20 = i
    s = 0
    while i > 0:
        s += i % 10
        i //= 10
    if s == 20:
        res += num20
print(res)

# Вариант
res = 0
for i in range(1000, 10000):
    if sum(list(map(int, str(i)))) == 20:
        res += i
print(res)
#  3489675


"""
Построить лесенку из чисел. Программа принимает на вход целое положительное число n (n<=15) - количество уровней, 
Вывести n уровней, в каждом из которых стоят числа от 1 до значения уровня.
Input:  3
Output: 1
        1 2
        1 2 3
"""
n = int(input())
for el in range(1, n + 1):
    for i in range(1, el + 1):
        print(i, end=' ')
    print()


"""
Напишите программу для построения горизонтальных столбчатых диаграмм с помощью символа звёздочки
Input:  3 7 1 10 8
Output: ***
        *******
        *
        **********
        ********
"""
lst = list(map(int, input().split()))
for el in lst:
    print('*' * el)


"""
Постулат Бертрана (теорема Бертрана-Чебышева, теорема Чебышева) гласит, 
что для любого n > 1 найдется простое число p в интервале n < p < 2n. 
Такая гипотеза была выдвинута в 1845 году французским математиком Джозефем Бертраном (проверившим ее до n=3000000) 
Нужно решить несколько более общую задачу: по числу n найти количество простых чисел p из интервала n < p < 2n.
Напомним, что число называется простым, если оно делится только само на себя и на единицу.
Программа принимает на вход целое число n (2 <= n <= 50000)
Input:  4
Output: 2
"""

def is_plain(num: int):
    """Проверка на простое число"""
    # Исключаем четные числа и единицу, но пропускаем двойку (2 - это простое число)
    if num % 2 == 0 and num != 2 or num == 1:
        return False
    # Проверяем нечетные делители (исключаем числа делящиеся на 3)
    divisor = 3
    while divisor ** 2 <= num:
        if num % divisor == 0:
            return False
        divisor += 2
    return True


n = int(input())
cnt = 0
for el in range(n + 1, 2 * n):
    if is_plain(el):
        cnt += 1
print(cnt)


#  Вариант
n = int(input())
cnt = 0
for i in range(n + 1, 2 * n):
    for j in range(2, int(i ** 0.5) + 1):
        if i % j == 0:
            break
    else:
        cnt += 1
print(cnt)


"""
СОРТИРОВКА ПУЗЫРЬКОМ.
отсортировать список по возрастанию при помощи пузырьковой сортировки, 
в случае если элементы соседние совпадают менять их ненужно.
В качестве ответа нужно вывести отсортированный список и 
какое количество раз пришлось переставлять элементы в процессе сортировки
Input:  7
        8 5 3 1 4 7 9
Output: 1 3 4 5 7 8 9
        9
"""
# n = 7
# ls = [8, 5, 3, 1, 4, 7, 9]

n = int(input())
ls = list(map(int, input().split()))
cnt = 0

for el in range(n - 1):
    flag = True  # Проверка факта обмена элементов списка (взводим перед началом нового цикла)
    for i in range(n - 1 - el):  # Новый внутренний цикл уменьшается на отсортированную часть справа
        if ls[i] > ls[i + 1]:
            ls[i], ls[i + 1] = ls[i + 1], ls[i]
            flag = False  # Если была замена, то меняем флаг
            cnt += 1  # Считаем кол-во замен.
    if flag:  # Если замены не было, значит список упорядочен. Выходим из внешнего цикла.
        break
print(*ls)
print(cnt)


"""
Задана система уравнений:
a ** 2 + b = n
a + b ** 2 = m
Нужно посчитать количество пар целых чисел (a, b) (0 <= a, b), которые удовлетворяют системе.
Входные данные:  два целых числа n, m (1 <= n, m <= 1000)

Осмысление задачи:
Первое условие:
a ** 2 + b = n	-->  значит a ** 2 может быть в диапазоне от 0 до n, т. к. (0 <= a, b)
Второе условие:
b >= 0  и  a + b ** 2 = m
Input:  9 3
Output: 1
"""
n, m = map(int, input().split())
cnt = 0  # кол-во решений
a = 0

# # Возможные значения для переменной 'a'
# while a ** 2 <= n:
#     b = n - a ** 2
#     a += 1

# Добавляем сюда уравнение для переменной 'b'
while a ** 2 <= n:
    b = n - a ** 2
    if b >= 0 and a + b ** 2 == m:
        # print(f'a: {a}, b: {b}')
        cnt += 1  # кол-во решений
    a += 1
print(cnt)
# print(f'Количество пар: {cnt}')


"""
СОРТИРОВКА ВСТАВКОЙ.
Программа получает на вход число n - количество элементов в списке, и затем в следующей строке сам список.
Отсортировать список по возрастанию при помощи сортировки вставками, 
в случае если элементы соседние совпадают менять их ненужно.
Input:  6
        5 4 2 15 6 6
Output: 2 4 5 6 6 15
"""
# n = 5
# lst = [10, 4, 6, 8, 2]

n = int(input())
lst = list(map(int, input().split()))

# # Через вложенный цикл for
for i in range(1, n):
    # print(*lst)  # Визуализация изменений в списке
    for k in range(i, 0, -1):  # Постепенно формируем сортируемый список в увеличивающейся левой части
        if lst[k] < lst[k - 1]:
            lst[k], lst[k - 1] = lst[k - 1], lst[k]
        else:
            break  # Исключаем лишние итерации
print(*lst)
"""
[10, 4, 6, 8, 2]
[4, 10, 6, 8, 2]
[4, 6, 10, 8, 2]
[4, 6, 8, 10, 2]
[2, 4, 6, 8, 10]
"""

# Классический пример через цикл while
for i in range(1, n):
    # print(*lst)  # Визуализация изменений в списке
    num = lst[i]  # сравниваемый элемент
    k = i - 1
    while k >= 0 and num < lst[k]:  # Постепенно формируем сортируемый список в увеличивающейся левой части
        lst[k + 1] = lst[k]
        k -= 1
    lst[k + 1] = num
print(*lst)
"""
[10, 4, 6, 8, 2]
[4, 10, 6, 8, 2]
[4, 6, 10, 8, 2]
[4, 6, 8, 10, 2]
[2, 4, 6, 8, 10]
"""
