# 7.5 Область видимости: локальная, глобальная и встроенная
""""""

"""
Глобальные переменные — это те, которые не определены внутри какой-либо функции и имеют глобальную область действия, 
тогда как локальные переменные — это те, которые определены внутри функции, 
и их область действия ограничена только этой функцией. 
Другими словами, мы можем сказать, что локальные переменные доступны только внутри функции, 
в которой они были инициализированы, тогда как глобальные переменные доступны во всей программе и внутри каждой функции.

Если вы хотите внутри функции работать с глобальной переменной, 
то нужно подсказать нашей функции при помощи ключевого слова global, что нам нужна именно переменная, 
находящаяся в глобальной области видимости. После этого любое изменение переменной s внутри функции, 
будет влиять и на значение глобальной переменной.
"""
def f():
    global s
    s += ' Two'
    print("Text:", s)

s = "One"
print('До вызова:', s)  # До вызова: One
f()  # Text: One Two
print('После вызова:', s)  # После вызова: One Two


def foo():
    s = 'One'
    s += ' Two'
    print("Text:", s)


s = "One"
print('До вызова:', s)  # До вызова: One
foo()  # Text: One Two
print('После вызова:', s)  # После вызова: One


"""
Пространства имен в Python

Всего в python существует 4 вида пространства имен:
    builtins (встроенное пространство имен) 
    global (глобальное пространство имен) 
    enclosing (объемлющее пространство имен) 
    local (локальное пространство имен) 
"""

# Встроенное пространство имен
"""
(built-in namespace) содержит имена, которые всегда доступны в любом месте в программе. 
Эти имена обычно связаны с важными объектами, такими как функции, типы данных, названия исключений.
Например, встроенное пространство имен содержит имена таких функций, как 
len, min и max, а также имена таких типов данных, как int, float и str. 
"""
print(dir(__builtins__))  # [... 'reversed', 'round', 'set',  'sorted',  'str', 'sum',  'tuple', 'type',  'zip']


# Глобальное пространство имен
"""
(global namespace) содержит имена, определенные на уровне основной программы, 
и создаётся сразу при запуске тела этой программы. 
Сохраняется же оно до момента завершения работы интерпретатора.
"""
def print_age():
    print(age)


age = 21
print_age()  # 21
print(globals())  # {....  'age': 21, 'print_age': <function print_age at 0x000002D048E3F0A0>}


# Локальное пространство имен
"""
Локальное пространство имен (local namespace) содержит имена, которые доступны только внутри определенной функции.
"""
def print_age():
    age_new = 21
    print(age_new)

print_age()  # 21
print(age_new) # NameError: name 'age_new' is not defined

# Объемлющее пространство имен
"""
Объемлющее пространство возникает, когда одна функция определена внутри другой функции. 
Внутренняя функция, также известная как вложенная функция, может обращаться к переменным, 
определенным во внешней функции, также известной как объемлющая функция.

В примере ниже:
outer_function — это объемлющая функция, 
а inner_function — вложенная. 
Функция inner_function имеет доступ к переменным x и y, 
определенной в функции outer_function.
"""
def outer_function():
    x = 15
    y = 10

    def inner_function():
        w = 40
        print(x + y + w)

    inner_function()

outer_function()  # 65


"""
Кроме того, вложенная функция может обращаться к нелокальным переменным объемлющей функции и изменять их. 
Для этого необходимо использовать ключевого слова nonlocal.
"""
def outer_function():
    x = 5
    def inner_function():
        nonlocal x
        x += 1
        print('внутри inner_function', x)  # внутри inner_function 6
    inner_function()
    print('внутри outer_function', x)  # внутри outer_function 6

outer_function()


# Правило LEGB
"""
При поиске переменных, Python использует правило LEGB. 
LEGB — это аббревиатура, обозначающая порядок, в котором Python ищет имена переменных, 
когда вы используете их в своем коде. Буквы означают:

L (local) — локальная область видимости
E (enclosing) — локальная область объемлющих функций
G (global) — глобальная область видимости
B (built-in) — встроенная
"""


#
#  *  *  *   Задачи   *  *  *
#


# 01
"""
Напишите функцию, которая принимает имя и возраст водителя. 
Функция должна распечатать на экран заключение, 
может ли данный водитель управлять транспортом и определять она должна это по возрасту водителя: 
он должен быть больше или равен MIN_DRIVING_AGE

Output:
allowed_driving('tim', 17) # "tim еще рано садиться за руль"
allowed_driving('bob', 18) # "bob может водить"
"""
MIN_DRIVING_AGE = 18

def allowed_driving(name: str, age: int) -> None:
    if age < MIN_DRIVING_AGE:
        print(f'{name} еще рано садиться за руль')
    else:
        print(f'{name} может водить')


# Оригинальное решение
MIN_DRIVING_AGE = 18
ANSWERS = ("еще рано садиться за руль", "может водить")
def allowed_driving(name, age):
    print(f'{name} {ANSWERS[age >= MIN_DRIVING_AGE]}')

# allowed_driving('tim', 17)
# allowed_driving('bob', 18)


# 02
"""
https://stepik.org/lesson/296973/step/14?unit=278701
Необходимо создать функцию get_word_indices, 
которая принимает список строк и возвращает словарь, 
где ключи - это уникальные слова из списка строк в нижнем регистре, 
а значения - это списки индексов строк, в которых эти слова встречаются.
Регистр букв не учитывается поэтому слова «String» и «STRING» считаются одинаковыми.

Output:
assert get_word_indices(['This is a string',
                         'test String',
                         'test',
                         'string']) => {'this': [0], 'is': [0], 'a': [0],
                                        'string': [0, 1, 3], 'test': [1, 2]}

get_word_indices(['Look at my horse',
                         'my horse',
                         'is amazing']) => {'look': [0], 'at': [0], 'my': [0, 1],
                                            'horse': [0, 1], 'is': [2], 'amazing': [2]}

get_word_indices([]) => {}

get_word_indices(['Avada Kedavra',
                         'avada kedavra',
                         'AVADA KEDAVRA']) => {'avada': [0, 1, 2],
                                               'kedavra': [0, 1, 2]}
"""
def get_word_indices(strings: list[str]) -> dict:
    d = dict()
    for i, el in enumerate(strings):
        for s in el.lower().split():
            if s not in d:
                d[s] = [i]
            else:
                d[s].append(i)
    return d
